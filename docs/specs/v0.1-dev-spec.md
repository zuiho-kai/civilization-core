# v0.1 开发规格书

> 基于 `prototype-design-v0.1.md` 的实现计划。目标：规则物理层跑通，硬编码决策，验证涌现现象。

## 1. 目标

用 ≤1200 行 Python（纯标准库）实现最小可运行文明内核，能模拟 100 个 Agent 运行 1000 虚拟时间单位，观察到基础涌现现象。

## 2. 模块划分与文件清单

```
civ_kernel/
├── models.py      # 数据模型（Agent, Organization, Event, World）
├── engine.py      # EventEngine 主循环 + 事件 dispatch
├── agent_engine.py # Agent 行为逻辑（wake_up 决策、Produce/Exchange/Coerce）
├── network.py     # WS 图生成、trust 管理、network_rewire
├── org.py         # 组织成立（Agent 发起）、解散、制度突变
├── resource.py    # ResourceLedger（因果审计）
├── metrics.py     # Gini、tension、局部价格方差
├── config.py      # 所有常量/默认参数集中管理
└── main.py        # 入口：初始化 → 运行 → 输出统计
```

## 3. 各模块接口签名

### 3.1 models.py（~120 行）

```python
@dataclass
class Agent:
    id: int
    wealth: float
    energy: float
    max_energy: float
    regen_rate: float
    neighbors: dict[int, float]       # agent_id → trust
    status: float
    producing: bool
    org_id: int | None
    disposition: dict[str, float]     # {gain, norm, trust}, sum=1
    learning_rate: float
    risk_aversion: float
    local_norm: float
    exchange_history: list[tuple]
    activity_level: float
    perception_noise: float
    last_event_time: float
    proposal_cooldown_until: float
    proposal_failures: int

@dataclass
class Organization:
    id: int
    members: set[int]
    rules: dict[str, float]           # 12 keys，见设计文档 §5.5.1
    treasury: float
    efficiency: float
    conflict_cost: float
    legitimacy: float
    recent_exits: int
    recent_joins: int

@dataclass(order=True)
class Event:
    trigger_time: float
    type: str                          # = field(compare=False)
    source_id: int                     # = field(compare=False)
    target_id: int | None              # = field(compare=False)
    payload: dict                      # = field(compare=False)

class World:
    agents: dict[int, Agent]
    orgs: dict[int, Organization]
    event_queue: list[Event]           # heapq
    clock: float
    ledger: ResourceLedger
    metrics_log: list[dict]            # 定期快照
```

### 3.2 config.py（~60 行）

所有常量集中，包括：
- `NUM_AGENTS = 100`
- `MAX_VIRTUAL_TIME = 1000.0`
- `WS_K = 10, WS_BETA = 0.15`
- `BASE_INTERVAL = 5.0`
- `ENERGY_THRESHOLD = 0.3`
- `PRODUCTION_EFFICIENCY = 1.0`
- `LOOT_RATIO = 0.3`
- `COUNTER_SEVERITY = 0.3`
- `MIN_ORG_SIZE = 3`
- `PROPOSE_TRUST_THRESHOLD = 0.6`
- `MUTATION_STEP = 0.05`
- `GRIEVANCE_THRESHOLD = 0.3`
- `METRICS_INTERVAL = 50`（每 50 个事件记录一次指标）
- 全部 Organization.rules 默认值
- 全部 power 参数（a1, a2, b1, b2）

### 3.3 engine.py（~80 行）

```python
class EventEngine:
    def __init__(self, world: World): ...
    def run(self) -> None:
        """主循环：pop event → advance clock → dispatch"""
    def schedule(self, event: Event) -> None:
        """heappush"""
    def dispatch(self, event: Event) -> None:
        """根据 event.type 路由到对应 handler"""
```

### 3.4 agent_engine.py（~300 行，最大模块）

```python
def handle_wake_up(world, agent_id) -> None:
    """Agent 醒来 → 回复 energy → 决策 → 执行 → schedule 下次 wake_up"""

def handle_produce_complete(world, agent_id, payload) -> None:
    """生产完成 → 释放锁定 → wealth 到账"""

def handle_exchange_request(world, source_id, target_id, payload) -> None:
    """Exchange 撮合：估值 → 协商 → 成交/拒绝 → trust/disposition 更新"""

def handle_coerce_attempt(world, source_id, target_id) -> None:
    """Coerce 流程：前置检查 → 代价计算 → 成功概率 → 结算 → 惩罚"""

def handle_org_proposal(world, source_id, payload) -> None:
    """组织提议：候选成员 EV 计算 → 投票 → 成立/失败"""

def compute_ev_produce(agent, world) -> float: ...
def compute_ev_exchange(agent, world) -> float: ...
def compute_ev_coerce(agent, target, world) -> float: ...
def compute_ev_join(agent, org, world) -> float: ...
def compute_ev_outside(agent, world) -> float: ...
def effective_power(agent, world) -> float: ...
def compute_grievance(agent, org) -> tuple[str, int]: ...
```

### 3.5 network.py（~120 行）

```python
def generate_ws_graph(n: int, k: int, beta: float) -> dict[int, dict[int, float]]:
    """生成 Watts-Strogatz 图 + 距离衰减 trust 初始化"""

def network_rewire(world, agent_id, rewire_ratio=0.3) -> None:
    """迁移时的网络重连"""

def update_trust(world, a_id, b_id, delta: float) -> None:
    """trust 变更（含边界 clamp）"""
```

### 3.6 org.py（~120 行）

```python
def handle_rule_mutation(world, org_id) -> None:
    """成员痛点驱动的制度突变"""

def check_org_dissolution(world, org_id) -> None:
    """成员数 < MIN_ORG_SIZE → 解散"""

def create_org(world, member_ids: list[int]) -> Organization: ...
def dissolve_org(world, org_id) -> None: ...
def join_org(world, agent_id, org_id) -> None: ...
def leave_org(world, agent_id) -> None: ...
```

### 3.7 resource.py（~60 行）

```python
class ResourceLedger:
    def transfer_wealth(self, world, from_id, to_id, amount) -> None: ...
    def produce(self, world, agent_id, energy_cost) -> float: ...
    def regen_energy(self, agent, elapsed) -> None: ...
    def audit_event(self, event, before, after) -> None: ...
```

### 3.8 metrics.py（~60 行）

```python
def compute_gini(agents) -> float: ...
def compute_tension(world) -> float: ...
def compute_price_variance(world) -> float: ...
def snapshot(world) -> dict: ...
def print_summary(metrics_log) -> None: ...
```

### 3.9 main.py（~40 行）

```python
def initialize_world() -> World: ...
def main():
    world = initialize_world()
    engine = EventEngine(world)
    engine.run()
    print_summary(world.metrics_log)
```

## 4. 实现顺序

| 阶段 | 内容 | 验证 |
|------|------|------|
| P1 | models.py + config.py + engine.py + main.py 骨架 | 空世界能启动，事件循环能跑 |
| P2 | network.py（WS 图生成）+ agent_engine.py（wake_up + produce） | 100 Agent 能生产，wealth 增长 |
| P3 | agent_engine.py（exchange 完整流程）+ resource.py | 交易发生，trust 变化 |
| P4 | agent_engine.py（coerce 完整流程） | 强制发生，有成功有失败 |
| P5 | org.py（组织成立 + 解散 + 制度突变）+ agent_engine.py（org_proposal） | 组织涌现 |
| P6 | metrics.py + 验收检查 | Gini > 0.3，组织存在，制度突变发生 |

## 5. 验收标准（同设计文档 §7）

- [x] 财富分层：Gini > 0.3 ✅ (0.5781)
- [x] Gini 非单调 ✅
- [x] 至少一次 rule_mutation_event ✅
- [x] 至少一个 Organization 自动成立 ✅ (11个)
- [x] Coerce 不是永远最优 ✅
- [x] 局部价格差异：price_variance > 0.05 ✅ (0.3231)

**状态**：v0.1 全部验收通过 (2025-01-XX)

## 6. 约束

- ≤1200 行（含注释空行）
- 仅 Python 标准库
- 无多线程/async
- 无数据库/Web 框架
- v0.1 用硬编码 EV 决策，v0.1.5 替换为 LLM

---

## 7. 实现过程关键修改记录

### 7.1 初始实现问题（第一至五轮调试）

**问题现象**：所有组织政策完全相同（税率0.000，再分配0.750），无论运行多久都不会改变。

**诊断与修复**：
1. **EV计算错误**：修正 `compute_ev_join` 中的税后收入计算
2. **参数失衡**：调整生产效率、税率、再分配等基础参数
3. **再分配机制**：实现按需再分配（穷人得到更多福利）
4. **组织维护成本**：税收先扣除管理成本再进入国库
5. **渐进式腐化**：效率和合法性随时间衰减
6. **改革冷却机制**：从绝对冷却改为基于组织年龄的相对冷却（2秒）

### 7.2 规则持久化问题（第六轮）

**问题**：新组织从零开始，无法继承现有制度经验。

**修复**：
- 修改 `handle_org_birth` 和 `create_org`
- 新组织从现有组织中随机选择一个作为"模板"继承规则配置
- 实现制度的代际传承机制

### 7.3 改革机制根本性缺陷（第七轮）⭐

**问题根源**：`_compute_grievance` 函数中 `max_gain` 初始化为 `0.0`，导致只有当改变规则能带来**正收益**时才会记录痛点。当前规则已是局部最优时，改革永远不会触发。

**关键修复**（org.py:288）：
```python
# 修改前
max_gain = 0.0  # ❌ 只记录正收益变化

# 修改后
max_gain = float('-inf')  # ✅ 总是选择最优方向，即使都是负收益
```

**影响**：
- 确保改革机制在任何情况下都能找到"相对最优"的改革方向
- 打破制度僵化，实现真正的制度演化动力学
- 即使系统处于局部最优，也能通过"损失最小"的方向探索新的制度空间

### 7.4 最终验收结果

**运行参数**：100个Agent，10000虚拟时间单位，耗时15分16秒

**关键指标**：
- Gini系数：0.5781（显著贫富分化）
- Gini范围：0.1013-0.5781（非单调波动）
- 组织数量：11个存活
- 总事件数：2,190,241
- 局部价格方差：0.3231
- 快照数：43,805

**核心突破**：第七轮修复使改革机制从"永不触发"变为"持续演化"，系统展现出真正的制度动力学特征。
