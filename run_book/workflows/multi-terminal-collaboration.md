# 多终端协作流程（五方评审结论 2026-02-20）

> 设计终端（Opus）产出 IR → SR → AR 三件套，开发终端读 SR + AR 编码

## 任务分流规则（入口门禁）

| 条件 | 路径 | 示例 |
|------|------|------|
| ≤3文件 + 单模块 + 逻辑自明 | Opus 一条龙（SR+AR+代码） | P1.1（3文件150行） |
| ≥4文件 或 跨模块 或 涉及 DB/API 契约变更 | Opus 写 SR+AR → 开发终端实施 | P1.2（9文件跨前后端+DB） |

> 含前端 UI 的功能：设计终端（Opus）在 SR/AR 之后额外产出 UI 设计稿（阶段 2.5），读取 `web/src/themes.css` 作为设计约束。

补充判断维度：文件数 + 模块耦合度 + 风险等级。4-8 文件看耦合度。

## AR 策略（硬规则：所有终端都需要 AR）

### 语义定义

AR = Architecture Review（技术设计）。描述"为什么这么做、风险在哪"，是编码终端的架构护栏。

### SR 与 AR 的边界

| 维度 | SR 覆盖 | AR 覆盖 | 禁止重复 |
|------|---------|---------|----------|
| 改什么文件、什么函数 | ✅ 改动清单 | ❌ 不重复列 | 改动清单 |
| 函数签名、参数类型 | ✅ 接口契约 | ❌ 不重复写 | 签名定义 |
| 校验规则、边界值 | ✅ 精确规则 | ❌ | 校验逻辑 |
| 为什么选这个方案 | ❌ | ✅ ADR 决策记录 | — |
| 异常传播路径 | ❌ | ✅ 异常策略 | — |
| 并发/竞态分析 | ❌ | ✅ 风险矩阵 | — |
| 副作用执行顺序 | ❌ | ✅ 时序图 | — |
| 安全检查点 | ❌ | ✅ 安全层级 | — |
| 可配置项 | ❌ | ✅ 配置清单 | — |
| 测试用例 | ✅ 断言条件级 | ❌ | 测试定义 |

### 详细度（按开发终端）

AR 由设计终端（Opus）产出，独立存放为 `AR-*.md`，不附在 SR 内。

| 开发终端 | AR 详细度 | 说明 |
|----------|-----------|------|
| Opus | 精简 AR：异常策略 + 安全检查 + 副作用时序 + 可配置项清单 | Opus 理解力够，AR 聚焦架构决策不铺细节 |
| Sonnet | 详细 AR：精简 AR + 伪代码 + 分支矩阵 + 文件级实现指引 | Sonnet 理解模糊 SR 会脑补，AR 铺平路省返工 token |

AR 必须覆盖（最低要求）：
1. **异常传播策略** — Provider 层抛异常 vs handler 层统一 catch，禁止吞异常返回空值
2. **副作用时序** — 先调用后扣费，失败不扣费
3. **安全检查层级** — SSRF（含 DNS rebinding）、信息泄露脱敏、输入回显
4. **可配置项清单** — 零 magic number，所有可配置值走 config

> DEV-38 教训：跳过 AR → P0×4 + P1×7 + P2×7。AR 不是开销，是防线。
> token 开销排序：一条龙（讨论膨胀 ~50k+）> SR+AR（~30k）> SR only（~25k）。
> 但 SR only 已被废弃 — 省下的 5k token 换不回 18 条 CR 问题的修复成本。

## SR 编写规范（Opus 产出）

### 语义定义

SR = System Requirement（系统需求）。描述"改什么、改成什么样"，是编码终端的直接输入。

### 详细度标准

- **必写**：功能目标、接口契约（函数签名）、数据模型变更、校验规则精确边界值、数据流向（哪个函数调哪个、参数怎么传）、改动清单（文件+函数级）、测试用例（断言条件级）
- **后端**：写到函数签名级（参数类型、返回值、异常类型）
- **前端**：写到组件职责 + 数据字段级（"AgentCard 新增 SOUL 展示区，逐字段展示非空项"），不写具体渲染代码
- **可选**：消除歧义的伪代码片段（≤10 行，删掉后开发终端仍能写对 → 该删）
- **禁止**：完整函数体（>10行）、具体 JSX/HTML/CSS 代码、完整 SQL、方法内部注释
- **验证**：开发终端读完 SR + AR 后只需决定实现细节（变量命名、循环方式等），关键设计决策必须由 SR 覆盖，架构细节必须由 AR 覆盖

## 并发策略

- 改同文件的 Phase 必须串行（如 P1.1 → P1.2 都改 autonomy_service.py）
- 独立模块的 Phase 可与其他 Phase 的设计阶段并行
- Phase 内 Task 串行（有依赖链）

## 分支策略

一 Phase 一分支（`feature/m6-p1.1`），ST 通过后 merge main，下一个 Phase 从最新 main 拉分支。

## 人类参与点（最小化）

| 卡点 | 必须/可选 | 说明 |
|------|----------|------|
| SR 确认 | 必须 | 防方向错误 |
| ST 失败归因 | 开发终端连续失败 2 次才介入 | 不让它盲目重试 |
| 代码冲突解决 | 必须 | 改同文件时人类决定优先级 |

## 流水线时间线（示例）

```
P1.1: Opus 一条龙 → merge main
                ↘ (并行) Opus 写 P1.2 SR
P1.2: 人类确认 SR → 开发终端实施 → merge main
                ↘ (并行) Opus 写 Phase2 SR
Phase2: ...
```

## Sonnet 踩坑预警

- 模糊 SR → Sonnet 不会主动质疑，会自行脑补（危险），所以 Sonnet 执行时必须有 AR
- 多文件协调 → 容易漏改/改错依赖，SR 必须列完整文件清单
- 错误恢复弱 → 连续失败 2 次人类介入，不让盲目重试
- 文件冲突 → 需要重新理解上下文，冲突文件必须等前序 Phase 完成
