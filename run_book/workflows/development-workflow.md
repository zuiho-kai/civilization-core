# 完整开发流程（四方协作）

> 从需求到上线的完整开发流程。文档模板见 [doc-templates.md](../templates/doc-templates.md)。

---

## 流程总览

```
需求输入
  ↓
阶段 0：五方脑暴会议（方向讨论，画饼）→ 用户拍板
  ↓
阶段 1：写 IR 草稿 → 五方评审会议（审稿）→ 修订 → 用户确认
  ↓
阶段 2：SR 需求拆分（设计终端编写）
  ↓
阶段 2a：AR 技术设计（设计终端编写，独立文件 AR-M*-xxx.md）
  ↓
阶段 2.5：UI 设计稿（设计终端产出）[仅含前端 UI 的功能]
  ↓
阶段 3：正向串讲（Developer → QA Lead）[可选]
  ↓
阶段 4：反向串讲（QA Lead → Developer）[可选]
  ↓
阶段 5：测试用例设计（QA Lead）
  ↓
阶段 6：开发实施（Claude Code 按设计稿写代码）
  ↓
阶段 6.5：UI 美学验收（独立 Agent + Playwright）[仅含前端 UI 的功能]
  ↓ ← 未通过则回到阶段 6 修复，再次验收
阶段 7：集成测试（QA Lead 验证 + Developer 修复）
  ↓
阶段 8：上线评审（四方确认）
```

**文档粒度**：根据复杂度调整（轻量级 vs 详细级），模板见 [doc-templates.md](../templates/doc-templates.md)

**串讲环节**：可选
- 简单修改/Bug 修复：可跳过
- 复杂功能/新模块：必须串讲

---

## 阶段 0：五方脑暴会议（方向讨论）

**目标**：在写任何正式文档之前，先把方案思路聊透，避免方向错误导致 IR 白写。

**参与**：Architect + Tech Lead + QA Lead + Developer + Human Proxy PM（五方）

**实现**：
1. 用 TeamCreate 创建五方团队，5 个角色 agent 常驻
2. 各角色基于用户提出的方向，发散讨论：备选方案、利弊、风险、范围边界
3. 汇总各方意见，提炼待用户拍板的关键决策
4. 用户拍板方向后，进入阶段 1

**重要：脑暴结束后不要 shutdown 团队。** 同一批 agent 在阶段 1 评审 IR 时复用，保留脑暴上下文。团队生命周期 = 阶段 0 创建 → 阶段 1 评审完成 → 用户确认 IR → 才 shutdown。

**产出**：
- **原始对话存档**：每个议题讨论结束后，立即将 agent 之间的完整对话原文存档到 `docs/specs/SPEC-XXX-功能名/讨论细节/RAW-脑暴-议题N-YYYY-MM-DD.md`。原文不做删减，保留所有发言（含被否决的方案、分歧点、用户插话）。这是不可恢复的一手资料，session 结束后 agent context 会丢失。
- **浓缩纪要**：基于原文提炼决策纪要，存入 `docs/specs/SPEC-XXX-功能名/讨论细节/R1-脑暴-YYYY-MM-DD.md`
- 关键决策汇总提交用户并同步到 `docs/discussions.md` 索引

**检查点**：
- [ ] 五方团队已创建，各角色已发言
- [ ] 议题已拆分（检查是否打包：不同维度的决策必须独立讨论）
- [ ] 各 agent 已收到完整背景（当前系统痛点 + 竞品参考 + 用户方向）
- [ ] 每个议题讨论结束后，原始对话已完整存档（RAW 文件）
- [ ] 关键决策已汇总并提交用户
- [ ] 用户已拍板方向（硬卡点：未拍板不得写 IR）
- [ ] 团队保持 idle（不 shutdown），等待阶段 1 复用

---

## 阶段 1：IR 草稿 + 五方评审会议

**目标**：基于用户拍板的方向写 IR 草稿，再由同一批五方 agent 评审。

**实现**：
1. 主 agent 基于阶段 0 拍板的方向写 IR 草稿（`01-需求原型.md` 对应章节）
2. IR 草稿写完后停下，SendMessage 给阶段 0 的同一批五方 agent 评审（agent 保持 idle 有完整脑暴上下文，直接复用）
3. 五方评审聚焦：与脑暴结论是否一致、功能点遗漏、验收标准覆盖度、范围蔓延
4. 汇总评审意见，修订 IR
5. 用户确认 IR → shutdown 五方团队 → 进入阶段 2

**注意**：如果脑暴和评审跨 session 导致 agent 进程已退出，需重新拉五方团队并传入脑暴纪要作为上下文。尽量在同一 session 内完成阶段 0 + 阶段 1。

**产出**：`docs/specs/SPEC-XXX-功能名/01-需求原型.md` 对应章节（已评审修订）+ 评审纪要存入 `docs/specs/SPEC-XXX-功能名/讨论细节/R2-评审-YYYY-MM-DD.md`

**检查点**：
- [ ] 阶段 0 已完成（五方脑暴 + 用户拍板方向）— 硬卡点，未完成不得写 IR
- [ ] IR 草稿已完成，五方评审已执行
- [ ] 评审意见已修订到 IR 中
- [ ] 用户已确认 IR
- [ ] 五方团队已关闭

---

## 阶段 2：SR 系统需求

**目标**：将 IR 拆分为可执行的系统需求。SR 描述"改什么、改成什么样"，是编码终端的直接输入。

**负责**：设计终端（Opus）

**编写规范**：详见 [multi-terminal-collaboration.md](./multi-terminal-collaboration.md) SR 编写规范（语义定义、详细度标准、禁止项）

**产出**：`docs/specs/SPEC-XXX-功能名/SR-*.md`

**检查点**：
- [ ] SR 符合编写规范（后端函数签名级、前端组件职责级）
- [ ] 用户已确认 SR

---

## 阶段 2a：AR 技术设计

**目标**：在 SR 基础上产出架构护栏。AR 描述"为什么这么做、风险在哪"，不重复 SR 已有内容。

**负责**：设计终端（Opus）

**编写规范**：详见 [multi-terminal-collaboration.md](./multi-terminal-collaboration.md) AR 策略（语义定义、SR/AR 边界表、详细度标准）

**产出**：`docs/specs/SPEC-XXX-功能名/AR-*.md`

**检查点**：
- [ ] AR 独立文件已产出
- [ ] 符合 AR 策略最低要求（ADR、异常、安全、时序、配置、风险）
- [ ] 未重复 SR 已有内容
- [ ] 用户已确认 AR

---

## 阶段 2.5：UI 设计稿（设计终端产出）

**触发条件**：功能包含新的前端 UI 组件或页面。纯后端/API 功能跳过此阶段。

**目标**：在写代码前，由设计终端（Opus）直接产出 UI 设计规格，开发终端按规格实现，保证视觉质量。

**执行**：
1. 设计终端（Opus）读取 `web/src/themes.css` 作为设计约束（颜色变量、间距体系、字号体系）
2. 基于 SR/AR 中的功能需求，产出 UI 设计稿
3. 设计稿保存到 `docs/specs/_ui-designs/YYYY-MM-DD-功能名.md`

**输出**：`docs/specs/_ui-designs/YYYY-MM-DD-功能名.md`，包含：
- 组件结构树
- 布局规格（尺寸、flex/grid、间距）
- 视觉规格（CSS 变量、圆角、阴影）
- 交互状态（hover、empty、loading）
- 关键 CSS 片段
- 验收标准（供阶段 6.5 使用）

**检查点**：
- [ ] 设计稿已生成并保存到 `docs/specs/_ui-designs/`
- [ ] 设计稿包含明确的验收标准（至少 5 条）
- [ ] 设计稿引用的 CSS 变量均存在于 `themes.css`
- [ ] 开发终端（Developer）已阅读设计稿，理解要求

---

## 阶段 3：正向串讲（Developer → QA Lead）

**目标**：Developer 向 QA Lead 讲解设计，确保 QA 理解实现方案。

**何时执行**：复杂功能必须，简单修改可跳过。

**产出**：
- Developer 更新 spec（补充 QA 提出的遗漏点）
- QA Lead 输出测试场景列表（初稿）

**检查点**：
- [ ] QA Lead 理解了设计
- [ ] spec 已补充遗漏点

---

## 阶段 4：反向串讲（QA Lead → Developer）

**目标**：QA Lead 用自己的话复述设计，确认双方理解一致。

**何时执行**：与正向串讲同步，复杂功能必须。

**产出**：
- 测试场景列表（最终版）
- spec 标记为"已串讲确认"

**检查点**：
- [ ] Developer 确认 QA 理解正确
- [ ] 测试场景列表已最终确认

---

## 阶段 5：测试用例设计

**目标**：QA Lead 编写详细测试用例（Given-When-Then 格式）。

**负责**：QA Lead

**产出**：`docs/tests/TEST-XXX.md`

**检查点**：
- [ ] 覆盖正常流程、异常流程、边界条件
- [ ] 测试数据和预期结果明确

---

## 阶段 6：开发实施

**目标**：前后端并行实施。

**分工**：
- 后端终端：只改 `server/`，遵循 spec 架构约束
- 前端终端：只改 `web/`，遵循 `docs/api-contract.md` 接口定义
- 每完成一个模块，编写单元测试
- 小进展记 `server/progress.md` 或 `web/progress.md`

**检查点**：
- [ ] 代码已实现，单元测试通过
- [ ] CR 前自检：对本次改动涉及的每个函数签名变更，`grep -rn "函数名" server/` 确认全量调用方已适配（含 dev API、测试文件、import 引用）
- [ ] 自测通过，代码已提交
- [ ] 进度已更新

---

## 阶段 6a：代码评审（CR）

**目标**：由独立 agent 审查已提交代码的质量、安全、规范，发现编码阶段引入的问题。

**与五方评审的区别**：

| 维度 | 五方评审 | CR |
|------|---------|-----|
| 审查对象 | IR / SR / AR（设计文档） | 已提交的代码 |
| 参与方 | 5 个角色 agent（Architect / Tech Lead / QA Lead / Developer / PM） | 1 个独立 agent |
| 阶段 | 阶段 0~1（设计阶段） | 阶段 6a（编码之后） |
| 关注点 | 方向、范围、架构决策 | 代码质量、安全漏洞、规范一致性 |

**执行**：
1. 用 Task 启独立 agent（`subagent_type=general-purpose`），不能是写代码的同一个 agent（"不能自己审自己"）
2. 独立 agent 读取：本次改动的代码 diff + 对应的 SR + AR + 错题本（`error-books/`）
3. 按以下维度审查：
   - **P1 阻断级**：功能错误、安全漏洞（OWASP Top 10）、数据丢失风险、接口契约违反
   - **P2 重要级**：异常处理缺失、边界条件未覆盖、性能隐患、测试覆盖不足
   - **P3 建议级**：命名规范、代码风格、可读性改进
4. 产出 CR 报告，按 P1/P2/P3 分级列出问题

**通过标准**：
- P1 = 0 且 P2 = 0 → PASS，进入下一阶段
- P1 > 0 或 P2 > 0 → FAIL，开发终端修复后重新提交 CR

**循环**：
```
独立 Agent CR → FAIL → 开发终端修复 → 重新 CR → 直到 PASS
```

**产出**：CR 报告记录在对应 Phase 的提交记录中（commit message 或 PR comment），P3 问题登记到 backlog

**检查点**：
- [ ] CR 由独立 agent 执行（非编码 agent 本身）
- [ ] CR 报告已产出，P1/P2/P3 分级明确
- [ ] P1 和 P2 问题已全部修复并重测
- [ ] P3 问题已登记（可不立即修复）

---

## 阶段 6.5：UI 美学验收（独立 Agent + Playwright）

**触发条件**：阶段 2.5 已执行（即本功能有前端 UI）。

**目标**：用 Task 启独立 agent 对照设计稿验收实际界面，确保美学质量达标后才进入集成测试。独立 agent 保证"不是自己审自己"（与 CR 规则一致）。

**执行**：
用 Task 启独立 agent（`subagent_type=general-purpose`），该 agent 使用 Playwright MCP 工具执行：
1. `browser_navigate` — 打开目标页面（确保开发服务器已运行）
2. `browser_take_screenshot` — 截图（Claude 多模态直接看图审查）
3. `browser_snapshot` — 拿 accessibility tree（语义结构审查）
4. `browser_evaluate` — 跑 `getComputedStyle` 验证精确数值（间距、颜色、字号）
5. 交互验证 — `browser_hover`、`browser_click` 验证 hover/active/focus 等交互状态

审查维度（7 维度打分）：
- 布局与间距、颜色与主题一致性、字体与排版、交互状态、响应式适配、可访问性、整体美感

**通过标准**：综合评分 ≥ 7/10 且无 P0 问题

**循环**：
```
独立 Agent 审查 → FAIL → 开发终端修复 → 重新审查 → 直到 PASS
```

**产出**：`docs/specs/_ui-reviews/YYYY-MM-DD-功能名.md`

**检查点**：
- [ ] 独立 Agent 审查结论为 PASS
- [ ] 审查报告已保存
- [ ] 所有 P0 问题已修复

---

## 阶段 7：集成测试

**目标**：QA Lead 按测试用例验证，Developer 修复 Bug。

**循环**：QA 测试 → 报告失败 → Developer 修复 → QA 重测 → 直到全部通过

**产出**：`docs/tests/REPORT-XXX.md`

**检查点**：
- [ ] 所有测试用例已执行
- [ ] 阻塞 Bug 已修复并重测通过
- [ ] 测试报告已输出

---

## 阶段 8：上线评审

**目标**：四方最终确认功能可以上线。

**实现**：
1. 确认测试报告全部通过
2. 确认代码已提交、文档已更新
3. 输出上线总结 `docs/releases/RELEASE-XXX.md`
4. 更新 `claude-progress.txt`（里程碑完成）

**检查点**：
- [ ] 四方确认完成
- [ ] 进度文件已更新

---

## 效率规则

1. **不回读自己刚写的文档** — 同一会话中刚产出的 IR/SR/PLAN 内容直接引用，不从磁盘重新加载
2. **并行读文件** — 需要读多个外部代码文件时，一次并行读完，不分批串行
3. **文档写作模型选择** — IR 五方评审 + SR 编写用 Opus（需要设计决策）；AR 编写用 Sonnet（结构化填充，不需要创造性决策）；TDD 等纯文本文档用 haiku/sonnet。均用子 task 写，不占用主 opus 上下文
4. **工具调用失败立即修正** — 读错误信息，修正参数，不盲目重试同一调用
5. **外部进程/CLI 排查先做环境全景扫描** — 排查子进程超时、连接失败等问题时，先花 5 分钟并行验证：① 代理变量（`env | grep -i proxy`）② 直连测试（`curl --noproxy "*"`）③ 配置文件实际路径（grep hardcoded path）④ 进程读的是哪份配置。多个假设并行验证，不串行等超时（参见 DEV-12）
6. **执行策略按复杂度选择** — 小任务（≤5 文件、单模块）一条龙直接编码（Opus 或 Sonnet 均可）；大任务（≥6 文件或跨前后端+测试）开 team 分发并行。中间再开子 agent 传上下文的通信开销往往大于直接干活的成本
7. **评审方式按级别选择** — 里程碑级 IR 评审用 TeamCreate 开 team（复用上下文，支持多轮追问）；SR 级轻量审核用 Task 单次调用即可

## 多终端协作流程

> 详见 [multi-terminal-collaboration.md](./multi-terminal-collaboration.md)（Opus/Sonnet 分工、SR 标准、AR 策略、并发策略、分支策略、Sonnet 踩坑预警）

---

## 流程适配规则

| 场景 | 可省略阶段 | 说明 |
|------|-----------|------|
| 简单 Bug 修复 | 1、3、4、8 | 直接写设计 → 测试 → 实施 → 测试 |
| 单文件小改动 | 1、2、3、4、5、8 | 直接实施 → 自测 |
| 紧急热修复 | 3、4 | 省略串讲，但必须有测试 |
| 文档更新 | 全部省略 | 直接修改，无需流程 |

---

## 版本
v1.1 - 2025-07-09（路径更新为 specs/，模板拆分到 doc-templates.md）
