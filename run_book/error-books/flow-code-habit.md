# 错题本 — 代码修改习惯

> 适用场景：改代码、改文档、修 P0/P1、批量操作

### 记录规则

- **条目结构**：❌ 错误做法 + ✅ 正确做法，整条控制在 **5 行以内**
- **❌/✅ 写法**：只写核心规则，禁止多层加粗嵌套（加粗最多一层）
- **`>` 注释**：只放归因路径字母和 postmortem 链接，禁止复述场景
- **复犯**：只追加频率标记（🟡×N / 🔴×N）
- **归属**：条目只写本范围内容，跨范围写到对应文件

### DEV-6 改代码不 grep 引用 + 不复用 pattern + 不对照 TDD `🟡中频×3`

❌ 改签名不 grep 全量引用→下游断裂；不 grep 同类实现从零写；dormant 子系统只改主调用链，遗漏次要入口
✅ 改前 grep 同类 pattern 复用→grep 全量引用→改后对照 TDD→涟漪推演。dormant 操作：`grep -rn` 穷举全部入口逐个处置。新增函数：先 Read 同文件已有函数对齐事务模式/错误格式/命名；涉及外部 API 的还须跨文件 grep 同类失败处理模式
> 详见 [postmortem-dev-bug-6.md](../postmortems/postmortem-dev-bug-6.md)、[postmortem-dev-bug-11.md](../postmortems/postmortem-dev-bug-11.md)

### DEV-24 更新文档只改局部不扫全文 `🟡×2`

❌ 只改最明显的一处，其余过时内容全部遗漏
✅ 更新文档前先全文扫描列出所有过时点，一次性全部更新。往规范文件追加前先读头部记录规则

### DEV-29 P0/P1 修复列表漏项 + 执行碎片化 `🟢`

❌ CR 列了 5 个 P1 只修 4 个；独立修改逐个串行
✅ P0/P1 逐条核销不漏项；独立修改并行发出；独立文件更新并行

### DEV-47 批量/seed 幂等设计未考虑"部分成功" `🟢`

❌ 照搬 `count > 0` 跳过的幂等模式到有外部 API 依赖的场景，部分失败后永远无法补全
✅ 涉及外部依赖的批量操作用细粒度差集（按业务键比对），每条用 savepoint 包裹，单条失败不影响整体
