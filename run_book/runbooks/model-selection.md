# 模型选择策略

> 子 Agent 调度的核心参考。三层金字塔，从上往下选。

---

## 三层金字塔

### 🔴 第 1 层：Opus（占比 10–20%）

只做高价值、不可替代的工作：

| 任务 | 说明 |
|------|------|
| 架构设计 | 跨模块方案、系统级设计 |
| 复杂算法 | 状态机、并发逻辑、WebSocket 编排 |
| 跨文件 refactor 规划 | 多模块联动的改动方案（规划，不是执行） |
| 重大决策 | 技术选型、方案取舍 |
| E2E / 集成测试 | 多 service 联动、mock LLM、复杂场景 |
| 测试矩阵设计 | 理解业务全貌，识别边界条件 |
| DevOps（多步骤） | 跨环境、错误恢复、全局规划 |

**判断口诀**：需要全局视野 or 错误恢复能力 → Opus。

### 🟡 第 2 层：Sonnet（占比 50–60%）

主力干活模型，覆盖大部分开发工作：

| 任务 | 说明 |
|------|------|
| 单文件修改 | CRUD、API 端点、UI 组件 |
| 单模块重写 | 一个 service 的重构 |
| 中等复杂度逻辑 | 业务规则、数据转换、校验逻辑 |
| 结构化生成 | 配置文件、schema、类型定义 |
| 单元测试编写 | seed → 调 service → assert，模式固定 |
| 需求评审 / 串讲 | 多方评估、理解验证 |
| 协作讨论 | 多角度分析（3–5 个并行，成本可控） |
| DevOps（单步骤） | 单个 SSH 命令、单个配置修改 |

**判断口诀**：单一环境 + 明确目标 + 不需要跨模块推理 → Sonnet。

### 🟢 第 3 层：Haiku（占比 20–30%）

低成本批量处理，不需要推理能力：

| 任务 | 说明 |
|------|------|
| 格式修正 | 缩进、换行、代码风格统一 |
| 变量重命名 | 批量替换、命名规范化 |
| 文档补全 | 进度更新、格式化写入 |
| 注释生成 | docstring、行内注释 |
| 小 patch | 单行修复、常量修改 |
| 文件操作 | Grep、Glob、Read、搜索 |
| 记录 | 会议纪要格式化、进度文件更新 |

**判断口诀**：不需要理解业务逻辑，只需要格式化/搬运 → Haiku。

---

## 快速决策流

```
接到子任务 →
  需要全局视野/跨模块推理？ → Opus
  需要理解业务逻辑并生成代码？ → Sonnet
  只是格式化/搬运/小修？ → Haiku
  拿不准？ → Sonnet（安全默认）
```

## 按角色映射

| 角色 | 模型 | 理由 |
|------|------|------|
| Architect | Opus | 全局视野 |
| Tech Lead | Sonnet | 技术判断和可行性 |
| Developer | Sonnet / Opus | 简单用 Sonnet，复杂用 Opus |
| QA Lead | Sonnet | 测试场景设计 |
| Discussion Expert | Sonnet | 多角度分析，并行时成本可控 |
| Recorder | **Haiku** | 格式化记录 |

## 主 Agent 定位

- **交互式讨论**：模型由用户启动时决定
- **批量执行**：主 agent 当调度器，把实际工作按三层分派给子 agent

---

## 测试用例委派策略

| 测试类型 | 模型 | 判断标准 |
|---------|------|---------|
| 单元测试 | **Sonnet** | seed → service → assert，模式固定 |
| E2E / 集成测试 | **Opus** | 多 service 联动、mock LLM、WebSocket |
| 测试矩阵设计 | **Opus** | 需要理解业务全貌 |

**Sonnet 写单元测试的 prompt 模板**：

```
Task(model="sonnet", subagent_type="general-purpose", prompt="""
写单元测试，要求：
- 被测模块：{模块路径}（源码附后）
- 测试风格：参考 {已有测试文件路径}
- fixture：使用 conftest.py 中的 db fixture（sqlite 内存库）
- 需要覆盖的 case：{测试矩阵列表}
- 命名规则：test_{编号}_{场景}
- 每个 test 函数独立，用 _seed_xxx helper 准备数据

[附：conftest.py 内容]
[附：被测模块源码]
[附：范例测试文件]
""")
```

**分工流程**：Opus 设计测试矩阵 → Sonnet 批量写单元测试 → Opus 审查 + 写 E2E 测试

---

## 踩坑记录

### 2026-02-14: Sonnet 做多步骤 DevOps 任务耗时过长

**任务**：git push + SSH 远程部署 + 写 Bot 脚本 + 端到端验证（一个 Task 包含 5 个串行步骤）

**耗时**：~23 分钟（79 次 tool call），Opus 预估 5-8 分钟

**原因分析**：
1. **任务粒度过大**：把 git push、远程部署、写脚本、验证全塞进一个 Task，Sonnet 缺乏全局规划能力，遇到问题时反复试错
2. **环境调试链路长**：远程 SSH + pip install + config 修复 + server 启动，每一步都可能出错，Sonnet 的错误恢复能力弱于 Opus
3. **不适合 Sonnet 的场景**：涉及多环境（本地 Windows + 远程 Linux）、多工具（git/gh/ssh/curl）、多步骤依赖的 DevOps 任务，实际复杂度高于"简单实施"

**教训**：
- **DevOps/部署类任务用 Opus**：涉及 SSH、环境配置、多步骤依赖的任务，Sonnet 容易在错误恢复上浪费大量 turn
- **或者拆成多个小 Task**：git push 一个 Task，远程部署一个 Task，写脚本一个 Task，各自独立
- **Sonnet 适合单一环境内的简单实施**：不要让它跨环境、跨工具链做复杂编排
